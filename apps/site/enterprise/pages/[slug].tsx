import { addArticleJsonLd } from '@starter-kit/utils/seo/addArticleJsonLd';
import { getAutogeneratedPostOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticPaths, GetStaticProps } from 'next';
import dynamic from 'next/dynamic';
import Link from 'next/link';
import { AppProvider } from '../components/contexts/appContext';
import { MarkdownToHtml } from '../components/features/blog/markdown-to-html';
import { ModernPostHeader } from '../components/features/blog/modern-post-header';
import { PostTOC } from '../components/features/blog/post-toc';
import { CaseStudyLayout } from '../components/features/case-studies/case-study-layout';
import { CaseStudyMarkdown } from '../components/features/case-studies/case-study-markdown';
import Chatbot from '../components/features/chatbot/Chatbot';
import ModernHeader from '../components/features/navigation/modern-header';
import { Container } from '../components/shared/container';
import { Layout } from '../components/shared/layout'; // Layout component automatically includes Footer - no need for explicit Footer import
import { SEOHead } from '../components/shared/seo-head';
import {
	PageByPublicationDocument,
	PostFullFragment,
	PublicationFragment,
	SinglePostByPublicationDocument,
	SlugPostsByPublicationDocument,
	StaticPageFragment,
} from '../generated/graphql';
import { generateArticleStructuredData } from '../lib/structured-data';
// @ts-ignore
import handleMathJax from '@starter-kit/utils/handle-math-jax';
import { useEmbeds } from '@starter-kit/utils/renderer/hooks/useEmbeds';
import { loadIframeResizer } from '@starter-kit/utils/renderer/services/embed';
import { useEffect, useState } from 'react';
// @ts-ignore
import { triggerCustomWidgetEmbed } from '@starter-kit/utils/trigger-custom-widget-embed';

const AboutAuthor = dynamic(() => import('../components/features/blog/about-author'), {
	ssr: false,
});
const Subscribe = dynamic(() =>
	import('../components/features/newsletter/subscribe').then((mod) => mod.Subscribe),
);
const PostComments = dynamic(() =>
	import('../components/features/blog/post-comments').then((mod) => mod.PostComments),
);

type PostProps = {
	type: 'post';
	post: PostFullFragment;
	publication: PublicationFragment;
};

type PageProps = {
	type: 'page';
	page: StaticPageFragment;
	publication: PublicationFragment;
};

type Props = PostProps | PageProps;

const Post = ({ publication, post }: PostProps) => {
	const highlightJsMonokaiTheme =
		'.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}';

	// Check if this is a case study
	const isCaseStudy = post.tags?.some((tag) => tag.slug === 'case-study');

	const tagsList = (post.tags ?? []).map((tag) => (
		<li key={tag.id}>
			<Link
				href={`/tag/${tag.slug}`}
				className="block rounded-full border px-2 py-1 font-medium hover:bg-slate-50 md:px-4 dark:border-neutral-800 dark:hover:bg-neutral-800"
			>
				#{tag.slug}
			</Link>
		</li>
	));
	const [, setMobMount] = useState(false);
	const [canLoadEmbeds, setCanLoadEmbeds] = useState(false);
	useEmbeds({ enabled: canLoadEmbeds });
	if (post.hasLatexInPost) {
		setTimeout(() => {
			handleMathJax(true);
		}, 500);
	}

	useEffect(() => {
		if (screen.width <= 425) {
			setMobMount(true);
		}

		if (!post) {
			return;
		}

		// TODO:
		// More of an alert, did this below to wrap async funcs inside useEffect
		(async () => {
			await loadIframeResizer();
			triggerCustomWidgetEmbed(post.publication?.id.toString());
			setCanLoadEmbeds(true);
		})();
	}, [post]);

	// If it's a case study, use the CaseStudyLayout
	if (isCaseStudy) {
		return (
			<>
				<SEOHead
					title={post.seo?.title || post.title}
					description={post.seo?.description || post.subtitle || post.brief}
					keywords={post.tags?.map(tag => tag.name) || []}
					canonical={post.url}
					ogImage={
						post.ogMetaData?.image ||
						post.coverImage?.url ||
						getAutogeneratedPostOG(post, publication)
					}
					ogType="article"
					author={post.author.name}
					publishedTime={post.publishedAt}
					modifiedTime={post.updatedAt}
					section={post.tags?.[0]?.name || undefined}
					tags={post.tags?.map(tag => tag.name) || []}
					structuredData={generateArticleStructuredData({
						headline: post.title,
						description: post.seo?.description || post.subtitle || post.brief,
						author: {
							name: post.author.name,
							description: 'Senior Front-End Developer',
							url: 'https://johnschibelli.com',
						},
						publisher: {
							name: publication.title,
							url: publication.url,
						},
						datePublished: post.publishedAt,
						dateModified: post.updatedAt,
						image: post.coverImage?.url,
						url: post.url,
						keywords: post.tags?.map(tag => tag.name),
					})}
				/>
				<CaseStudyLayout post={post} publication={publication}>
					<CaseStudyMarkdown contentMarkdown={post.content.markdown} />
				</CaseStudyLayout>
			</>
		);
	}

	// Regular post layout
	return (
		<>
			<SEOHead
				title={post.seo?.title || post.title}
				description={post.seo?.description || post.subtitle || post.brief}
				keywords={post.tags?.map(tag => tag.name) || []}
				canonical={post.url}
				ogImage={
					post.ogMetaData?.image ||
					post.coverImage?.url ||
					getAutogeneratedPostOG(post, publication)
				}
				ogType="article"
				author={post.author.name}
				publishedTime={post.publishedAt}
				modifiedTime={post.updatedAt}
				section={post.tags?.[0]?.name || undefined}
				tags={post.tags?.map(tag => tag.name) || []}
				structuredData={generateArticleStructuredData({
					headline: post.title,
					description: post.seo?.description || post.subtitle || post.brief,
					author: {
						name: post.author.name,
						description: 'Senior Front-End Developer',
						url: 'https://johnschibelli.com',
					},
					publisher: {
						name: publication.title,
						url: publication.url,
					},
					datePublished: post.publishedAt,
					dateModified: post.updatedAt,
					image: post.coverImage?.url,
					url: post.url,
					keywords: post.tags?.map(tag => tag.name),
				})}
			/>
			<ModernPostHeader
				title={post.title}
				coverImage={post.coverImage?.url}
				date={post.publishedAt}
				author={post.author}
				readTimeInMinutes={post.readTimeInMinutes}
			/>
			{post.features.tableOfContents.isEnabled &&
				post.features?.tableOfContents?.items?.length > 0 && <PostTOC />}
			<MarkdownToHtml contentMarkdown={post.content.markdown} />
			{post.tags && post.tags.length > 0 && (
				<div className="mx-auto w-full px-5 text-slate-600 md:max-w-screen-md dark:text-neutral-300">
					<div className="flex flex-wrap justify-center gap-2">
						{post.tags.map((tag) => (
							<Link
								key={tag.id}
								href={`/tag/${tag.slug}`}
								className="border-border bg-background text-muted-foreground hover:bg-accent hover:text-accent-foreground inline-flex items-center rounded-full border px-3 py-1 text-sm font-medium transition-colors"
							>
								#{tag.slug}
							</Link>
						))}
					</div>
				</div>
			)}
			<AboutAuthor />
			{!post.preferences.disableComments && post.comments.totalDocuments > 0 && <PostComments />}
			<Subscribe />
		</>
	);
};

const Page = ({ page }: PageProps) => {
	const title = page.title;
	return (
		<>
			<SEOHead
				title={title}
				description={page.description || 'Static page content'}
				canonical={page.slug}
				ogType="website"
			/>
			<MarkdownToHtml contentMarkdown={page.content.markdown} />
		</>
	);
};

export default function PostOrPage(props: Props) {
	const maybePost = props.type === 'post' ? props.post : null;
	const maybePage = props.type === 'page' ? props.page : null;
	const publication = props.publication;

	return (
		<AppProvider publication={publication} post={maybePost} page={maybePage}>
			<Layout>
				<ModernHeader publication={publication} />
				<Container className="pt-10">
					<article className="flex flex-col items-start gap-10 pb-10">
						{props.type === 'post' && <Post {...props} />}
						{props.type === 'page' && <Page {...props} />}
					</article>
				</Container>
				<Chatbot />
			</Layout>
		</AppProvider>
	);
}

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) {
		throw new Error('No params');
	}

	const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT || 'https://gql.hashnode.com/';
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST || 'mindware.hashnode.dev';
	const slug = params.slug;

	// Check if GraphQL is available
	if (!request) {
		console.warn('GraphQL not available, returning not found');
		return {
			notFound: true,
			revalidate: 1,
		};
	}

	try {
		const postData = await request(GQL_ENDPOINT, SinglePostByPublicationDocument, { host, slug });

		if (postData.publication?.post) {
			return {
				props: {
					type: 'post',
					post: postData.publication.post,
					publication: postData.publication,
				},
				revalidate: 1,
			};
		}

		const pageData = await request(GQL_ENDPOINT, PageByPublicationDocument, { host, slug });

		if (pageData.publication?.staticPage) {
			return {
				props: {
					type: 'page',
					page: pageData.publication.staticPage,
					publication: pageData.publication,
				},
				revalidate: 1,
			};
		}

		return {
			notFound: true,
			revalidate: 1,
		};
	} catch (error) {
		console.error('Error fetching post/page data:', error);
		return {
			notFound: true,
			revalidate: 1,
		};
	}
};

export const getStaticPaths: GetStaticPaths = async () => {
	const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT || 'https://gql.hashnode.com/';
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST || 'mindware.hashnode.dev';

	// Check if GraphQL is available
	if (!request) {
		console.warn('GraphQL not available, returning empty paths');
		return {
			paths: [],
			fallback: 'blocking',
		};
	}

	try {
		const data = await request(GQL_ENDPOINT, SlugPostsByPublicationDocument, {
			first: 10,
			host: host,
		});

		const postSlugs = (data.publication?.posts.edges ?? []).map((edge: any) => edge.node.slug);

		return {
			paths: postSlugs.map((slug: any) => {
				return {
					params: {
						slug: slug,
					},
				};
			}),
			fallback: 'blocking',
		};
	} catch (error) {
		console.error('Error fetching static paths:', error);
		return {
			paths: [],
			fallback: 'blocking',
		};
	}
};
